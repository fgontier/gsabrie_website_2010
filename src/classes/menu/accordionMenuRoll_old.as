/*******************************************************************************SIMPLE XML ACCORDION MENU********************************************************************************This menu system was written as a means to display images in a condensed manner.Simple XML based accordion menu. Menu acts as a content space minimiser, with content hidden behind menu bar items. Contentslides into view when the menu item is clicked on. Menu supports parsing function calls from the XML file, along with parameter support for these functions. This is useful for perhapscalling a function on the parent timeline of the menu. Menu also supports a standard URL call from the XML, but this runs with on the first click ofthe menu item, so it is perhaps better to use SWFs to achieve this kind of functionality. You can of course have no action supplied.Menu supports both images and swfs. Loaded swfs can contain their own interactivity and can call parent functions. Menu supports using either the whole menu or just the menu bar as the mechansim for sliding the menu up and down. Generally it is better to only usethe bar if you want to include interactivity in the menu items.Positioning menu: Provide it with start values in the class below, then it positions itself based off the barHeight and menuPadding variables. Tocreate a column, or otherwise change menu item positions, set either the menuPosX or menuPosY values, like so, accordionMenu.menuPosX = newValueMenu supports custom events, so that individual menu instances can be targetted. Doing so relies on the MenuEvent class, which allows for the passingof one parameter (ID) which is an integer. This param is checked against the ID var of each menu, if they match, then the menu acts on the event. If youwant to be able to send other params to the menus, edit the MenuEvent Class. Each menu obtains an ID that matches its instantiation order, starting from 0, whicis the first menu.Dispatch events to individual menu items like so;//dispatch a new event telling the 3 menu item to opendispatchEvent(new MenuEvent(MenuEvent.MENU_EVENT,3));********************************************************************************SAMPLE USEAGE********************************************************************************//load the menu content - (loader content, title text, menu action)var newMenu:accordionMenu = new accordionMenu(loader.content, menuXML.menuitem.names.text()[p], menuXML.menuitem.action.text()[p]);********************************************************************************NOTES********************************************************************************Use either Tweener or TweenLite to animate the menus. Currently menu is using TweenLite, but should you want touse Tweener, then comment out TweenLite references, and uncomment Tweener References.TweenLite from here;http://blog.greensock.com/tweenliteas3Tweener from here;http://code.google.com/p/tweener/Made in 2007 by noponieshttp://www.blog.noponies.comTerms of usehttp://www.blog.noponies.com/terms-and-conditions********************************************************************************/package classes.menu {	import classes.graphic.TextHandle;	import com.gaiaframework.api.IBitmap;	import flash.display.*;	import flash.display.Stage;	import flash.events.*;	import gs.TweenLite;	//using TweenLite to tween the y property	import flash.text.*;	import flash.net.*;			public class accordionMenuRoll extends Sprite {		/*******************************************************************************/		/*USER DEFINABLE MENU VARIABLES		/*******************************************************************************/		private var barHeight:int = 14;//height of menu bar		private var menuPadding:int = 6;//space between menuitems		public static  var menuPosY:int = 30 //start y position of first menu item, this is a static var, that increments with each menu item, adjust for column layouts..		public static  var menuPosX:int = 19//start x value of first menu item		private var speed:Number = .5;//menu transition speed - in seconds		private var useWholeMenu:Boolean = true;//use the whole menu or just the black bar to trigger menu shuffles, default is true, use the whole menu		private var menuColour:int = 0xcccccc; //menu bars colour		private var useHighLighting:Boolean = true//change colours of bar on rollOver?		private var menuHighlightColour:int = 0x000000//menu rollover colour		/*******************************************************************************/		/*REQUIRED VARS		/*******************************************************************************/		private var startY:int;//a value indicating the starting y position of each menu item		public static  var SHUFFLEPOS:String = "shufflepos";//set up for custom event dispatch		public static  var RESETPOS:String = "resetpos";//set up for custom event dispatch		public static  var RESETALL:String = "resetall";//Reset all menu items		private var menuBar:Sprite;//the menu bar		public var contentHolder:Sprite;//sprite to hold loaded content		private var menuTxt:TextField;//menu bars text		private var menuFormat:TextFormat;//text formating for menu bar text		private var masker:Shape;//mask the shape of the menus content		private var activated:Boolean=false;//var to track if the menu is expanded.		public static var counter:int = 0//counter var, used to give a menu an ID		public var id:Number //id var		// below vars passed in via arguments to constructor		private var loadedContent:*;//content of loader - varies		private var menuText:String;		private var sectionText:String;		private var sectionCopy:TextHandle;		private var action:String;//temp var for passing each menu an action							private var pcLB:RegExp = /\r\n/g;		private var macLB:RegExp = /\r/g;		private var linuxLB:RegExp = /\n/g;		public function accordionMenuRoll(loadedContent:DisplayObject, menuTitle:String, menuText:String, menuAction:String) {						action = menuAction;			//generic setup			menuPosY+=(barHeight+menuPadding)//positioning of menu, vertically = barheight + menu padding						buttonMode = true;			useHandCursor = true;			mouseChildren = true;						//Give each menu an ID			this.id = counter++;			//this.id = menuTitle;			//add content			contentHolder = new Sprite();						sectionCopy = new TextHandle(700, 20, 241, 10, 12, 0x333333, "left", true, "left", false, false, true, "arial");			menuText = menuText.replace(pcLB, "\n");			menuText = menuText.replace(macLB, "\n");				sectionCopy.text = menuText;			contentHolder.addChild(sectionCopy);												contentHolder.y = -loadedContent.height;//set a negative height so content is hidden behind menu bar			contentHolder.addChild(loadedContent);			addChild(contentHolder);		//trace ("loadedContent " + loadedContent.height)							//mask			masker = new Shape();			masker.graphics.beginFill(0xFFccFF);			masker.graphics.drawRect(0, barHeight + 10, contentHolder.width+10, contentHolder.height+10);			masker.graphics.endFill();			addChild(masker);			contentHolder.mask = masker;//mask the loaded content			//visible bar sprite			menuBar = new Sprite();			menuBar.graphics.beginFill(menuColour);			menuBar.graphics.drawRect(0, 0, loadedContent.width, barHeight);//height, width of menu bar			menuBar.graphics.endFill();			addChild(menuBar);//add in the black menu bar						var sectionTitle:TextHandle = new TextHandle(0, 0, 240, 0, 13, 0xcccccc, "left", false, "left", false, false, false,"arial");			sectionTitle.text = menuTitle;		trace ("menuTitle " + menuTitle)			menuBar.addChild(sectionTitle);						//position the menu using provide vars			this.x = menuPosX			this.y = menuPosY							//event listeners			//check to see if we are gonna use the whole menu or just the black bar			if (useWholeMenu) {				addEventListener(MouseEvent.CLICK, mouseClickHandler);			} else {				menuBar.addEventListener(MouseEvent.CLICK, mouseClickHandler);			}						addEventListener(MouseEvent.ROLL_OUT, rollOutHandler); //use rollovers in order to treat each instance as a whole and so we only fire one event.			addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);//comment out this listener to make the menus stay open even if rolled out.			addEventListener(MouseEvent.ROLL_OVER, mouseOverHandler);						//stage added event listener			addEventListener(Event.ADDED_TO_STAGE, addedHandler);//use stage as listener for custom events						}				//added to stage handler		private function addedHandler(event:Event):void {			stage.addEventListener(accordionMenuRoll.SHUFFLEPOS, shuffleHandler);			stage.addEventListener(accordionMenuRoll.RESETPOS, resetHandler);			//custom event listener			stage.addEventListener(MenuEvent.MENU_EVENT,CustomMenuEventHandler, true);			startY = event.target.y;//find out our start ypos		}				//click		private function mouseClickHandler(event:MouseEvent):void 		{ 			dispatchEvent(new Event(accordionMenuRoll.RESETPOS,true));			TweenLite.to(this.contentHolder, speed, {y:barHeight});			dispatchEvent(new Event(accordionMenuRoll.SHUFFLEPOS,true));			this.activated = true;						//////////// Dispatch event to pass what menu has been clicked			dispatchEvent(new MenuEvent("MENU_EVENT", this.id));			//trace("this.id  " + this.id)		}						/*mouse move handler, used to trigger a variable that enables smoother dowards movement through the menus		basically this creates a 'active zone', which triggers a switch of the activated variable. If we are inside this zone, we keep it true. This		helps with downwards mouse movement across the menus.*/		private function mouseMoveHandler(event:MouseEvent):void {			if (stage.mouseY<=this.y+2 || stage.mouseY>=this.y+(this.menuBar.height+this.masker.height)-2 || stage.mouseX<=this.x+20 || stage.mouseX>=this.x+this.width-20) {			this.activated = false			}		}				//rollout		private function rollOutHandler(event:MouseEvent):void {			if(useHighLighting){				TweenLite.to(this.menuBar, speed, {tint:menuColour});				//Tweener.addTween(this.menuBar,{_color:menuColour, time:speed});							}			if (!this.activated) {				dispatchEvent(new Event(accordionMenuRoll.RESETPOS,true));				TweenLite.to(this.contentHolder, speed, {y:-this.contentHolder.height});				//Tweener.addTween(this.contentHolder,{y:-this.contentHolder.height, time:speed});				this.activated = false;			}		}		//rollover		private function mouseOverHandler(event:MouseEvent):void {			if(useHighLighting){				TweenLite.to(this.menuBar, .1, {tint:menuHighlightColour});				//Tweener.addTween(this.menuBar,{_color:menuHighlightColour, time:.4});			}			dispatchEvent(new Event(accordionMenuRoll.RESETPOS,true));			TweenLite.to(this.contentHolder, speed, {y:barHeight});			//Tweener.addTween(this.contentHolder,{y:barHeight, time:speed});			dispatchEvent(new Event(accordionMenuRoll.SHUFFLEPOS,true));			this.activated = true;		}				//reset position of clips listener handler		private function resetHandler(event:Event):void {			TweenLite.to(this, speed, {y:startY});			//Tweener.addTween(this,{y:startY, time:speed });			this.activated = false;//reset this var to indicate that menus are closed. Stops an issue where a menu can be activated, ie opened, but then a user			//can click on a different menu, resulting in the original menus activated state not getting reset. 		}				//custom menu event handler, send an event to a particular menu, in this instance, telling it to expand		private function CustomMenuEventHandler(event:*):void {			if (event.menuId == this.id) {				dispatchEvent(new Event(accordionMenuRoll.RESETPOS,true));				TweenLite.to(this.contentHolder, speed, {y:barHeight});				dispatchEvent(new Event(accordionMenuRoll.SHUFFLEPOS,true));				this.activated = true;			}		}				//shuffle the clips positions, dependent on their x pos and y pos in relation to the currently active menu		//using xpos gives us column support		private function shuffleHandler(event:Event):void {			if (this!==event.target) {				//slide the bars back up				TweenLite.to(this.contentHolder, speed, {y:-this.contentHolder.height});				//Tweener.addTween(this.contentHolder,{y:-this.contentHolder.height, time:speed});			}			if ((this.y>event.target.y) && (this.x == event.target.x)) {				//slide the bars back up				TweenLite.to(this, speed, {y:startY+event.target.contentHolder.height});				//Tweener.addTween(this,{y:startY+event.target.contentHolder.height, time:speed});			}		}				//kill listeners, call if needed		public function killListeners(event:Event):void{			removeEventListener(MouseEvent.ROLL_OUT, rollOutHandler); 			removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			removeEventListener(MouseEvent.ROLL_OVER, mouseOverHandler);			removeEventListener(Event.ADDED_TO_STAGE, addedHandler);			stage.removeEventListener(accordionMenuRoll.SHUFFLEPOS, shuffleHandler);			stage.removeEventListener(accordionMenuRoll.RESETPOS, resetHandler);			stage.removeEventListener(MenuEvent.MENU_EVENT,CustomMenuEventHandler);					}	}}